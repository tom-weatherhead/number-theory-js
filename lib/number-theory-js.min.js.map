{"version":3,"sources":["number-theory-js.js"],"names":["global","gcd","m","n","parseInt","isNaN","Error","gcdExtended","a","b","x","y","g","gcdResultObject","Math","floor","isPrime","primes","p","sieve","push","factorize","factors","m_increment","condenseFactorList","result","forEach","divisorHelper","factorsAsObject","primeFactors","i","numPrimeFactors","accumulator","j","result2","length","concat","divisors","Object","keys","map","sort","sum","array","reduce","isPerfect","removeDuplicates","Array","from","Set","totient","partial","exports","define","amd","version","module","window"],"mappings":"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","file":"unknown","sourcesContent":["/**\n * The Sieve of Eratosthenes (an ancient Greek prime number generator) as a JavaScript library\n *\n * @author Tom Weatherhead\n * @copyright 2018\n * @license MIT\n * @version 0.0.0\n */\n(function (global) {\n\n\t// See https://en.wikipedia.org/wiki/Group_(mathematics)\n\t// See https://en.wikipedia.org/wiki/Group_theory\n\t// See https://www.geeksforgeeks.org/number-theory-interesting-facts-and-algorithms/\n\n\t/**\n\t * gcd\n\t *\n\t * @method gcd\n\t * @param  {Mixed}   m          String, Int or Float representation of the first number\n\t * @param  {Mixed}   n          String, Int or Float representation of the second number\n\t * @return {Int}                The greatest common divisor of m and n\n\t */\n\tfunction gcd (m, n) {\n\t\t// See https://en.wikipedia.org/wiki/Euclidean_algorithm\n\n\t\tm = parseInt(m, 10);\n\t\tn = parseInt(n, 10);\n\n\t\tif (isNaN(m) || isNaN(n)) {\n\t\t\tthrow new Error('Invalid arguments');\n\t\t// } else if (m < 0) {\t\t// Unnecessary check; implicitly handled by the following two checks.\n\t\t\t// return gcd(-m, n);\n\t\t} else if (n < 0) {\n\t\t\treturn gcd(m, -n);\n\t\t} else if (m < n) {\n\t\t\treturn gcd(n, m);\n\t\t} else if (n === 0) {\n\t\t\treturn m;\n\t\t} else {\n\t\t\treturn gcd(n, m % n);\n\t\t}\n\t}\n\n\t// Partial application for functional programming:\n\tgcd.partial = m => n => gcd(m, n);\n\n\t/**\n\t * gcdExtended\n\t *\n\t * @method gcdExtended\n\t * @param  {Mixed}   a          String, Int or Float representation of the first number\n\t * @param  {Mixed}   b          String, Int or Float representation of the second number\n\t * @return {Object}             Object containing keys x, y, and g such that a * x + b * y === g. g is the greatest common divisor of a and b.\n\t */\n\tfunction gcdExtended (a, b) {\n\t\t// See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n\t\t// See https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended/\n\n\t\ta = parseInt(a, 10);\n\t\tb = parseInt(b, 10);\n\n\t\tif (isNaN(a) || isNaN(b)) {\n\t\t\tthrow new Error('Invalid arguments');\n\t\t}\n\n\t\tif (a === 0) {\n\t\t\treturn {\n\t\t\t\tx: 0,\n\t\t\t\ty: 1,\n\t\t\t\tg: b\n\t\t\t};\n\t\t}\n\n\t\tconst gcdResultObject = gcdExtended(b % a, a);\n\n\t\t// console.log('gcdExtended:', gcdResultObject);\n\n\t\treturn {\n\t\t\tx: gcdResultObject.y - Math.floor(b / a) * gcdResultObject.x,\n\t\t\ty: gcdResultObject.x,\n\t\t\tg: gcdResultObject.g\n\t\t};\n\t}\n\n\t/**\n\t * isPrime\n\t *\n\t * @method isPrime\n\t * @param  {Int}   \t\tm          \t\tThe integer to be tested\n\t * @param  {Array<Int>}\tprimes          The array of primes found thus far\n\t * @return {Boolean}                \tThe Boolean that indicates whether or not m is prime\n\t */\n\tfunction isPrime (m, primes) {\n\n\t\tfor (let p of primes) {\n\n\t\t\tif (p * p > m) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (m % p === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * sieve\n\t *\n\t * @method sieve\n\t * @param  {Mixed}   n          \t\tString, Int or Float representation of the ceiling\n\t * @return {Array<Int>}                \tThe list of prime numbers less than n\n\t */\n\tfunction sieve (n) {\t\t\t\t\t// eslint-disable-line no-unused-vars\n\t\t// See https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n\t\t// Ensure than n is an integer. Convert if necessary.\n\t\tn = parseInt(n, 10);\n\n\t\tif (isNaN(n)) {\n\t\t\tthrow new Error('Invalid argument');\n\t\t} else if (n <= 2) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet primes = [2];\n\n\t\tfor (let m = 3; m < n; m += 2) {\n\n\t\t\tif (isPrime(m, primes)) {\n\t\t\t\tprimes.push(m);\n\t\t\t}\n\t\t}\n\n\t\treturn primes;\n\t}\n\n\t/**\n\t * factorize\n\t *\n\t * @method factorize\n\t * @param  {Mixed}   n          \t\tString, Int or Float representation of n, the integer to factorize\n\t * @return {Array<Int>}                \tThe list of prime factors of n\n\t */\n\tfunction factorize (n) {\t\t\t\t\t// eslint-disable-line no-unused-vars\n\t\tn = parseInt(n, 10);\n\n\t\tif (isNaN(n) || n < 2) {\n\t\t\tthrow new Error('Invalid argument');\n\t\t}\n\n\t\tlet primes = [];\n\t\tlet factors = [];\n\t\tlet m = 2;\n\t\tlet m_increment = 1;\n\n\t\t//while (true) {\t\t// eslint-disable-line no-constant-condition\n\t\tfor (;;) {\n\n\t\t\tif (m * m > n) {\n\t\t\t\tfactors.push(n);\n\n\t\t\t\treturn factors;\n\t\t\t}\n\n\t\t\tif (isPrime(m, primes)) {\n\t\t\t\tprimes.push(m);\n\n\t\t\t\twhile (n % m === 0) {\n\t\t\t\t\tn /= m;\n\t\t\t\t\tfactors.push(m);\n\n\t\t\t\t\tif (n === 1) {\n\t\t\t\t\t\treturn factors;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm += m_increment;\n\t\t\tm_increment = 2;\n\t\t}\n\n\t\t// Unreachable code:\n\t\t//console.log('Return 3', original_n, n, primes, factors);\n\n\t\t//return factors;\n\t}\n\n\t/**\n\t * condenseFactorList\n\t *\n\t * @method condenseFactorList\n\t * @param  {Array<Int>}   factors\t\t\tThe prime factorization of a positive integer\n\t * @return {Object}\t\t\t\t\t\t\tThe factors after grouping. The object's keys are primes, and the corresponding values are exponents.\n\t */\n\tfunction condenseFactorList (factors) {\n\t\t// E.g. [ 2, 2, 2, 3, 3, 5, 7 ] -> { '2': 3, '3': 2, '5': 1, '7': 1 }\n\t\tlet result = {};\n\n\t\tfactors.forEach(p => {\n\t\t\tresult[p] = (result[p] || 0) + 1;\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tfunction divisorHelper (factorsAsObject, primeFactors, i, numPrimeFactors, accumulator) {\n\t\t//console.log(`divisorHelper() : factorsAsObject = ${factorsAsObject} ; primeFactors = ${primeFactors} ; i = ${i} ; numPrimeFactors = ${numPrimeFactors} ; accumulator = ${accumulator}`);\n\n\t\tif (i >= numPrimeFactors) {\n\t\t\t//console.log('Returning:', [accumulator]);\n\n\t\t\treturn [accumulator];\n\t\t\t//return Array.from(accumulator);\n\t\t}\n\n\t\tconst p = primeFactors[i];\n\t\tlet result = [];\n\n\t\tfor (let j = 0; j <= factorsAsObject[p]; j++) {\n\t\t\tconst result2 = divisorHelper(factorsAsObject, primeFactors, i + 1, primeFactors.length, accumulator);\n\n\t\t\t//console.log('concat', result, 'with', result2);\n\t\t\tresult = result.concat(result2);\n\t\t\t//console.log('concat result:', result);\n\t\t\taccumulator *= p;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfunction divisors (n) {\n\t\tconst factorsAsObject = condenseFactorList(factorize(n));\n\t\t//console.log('factorsAsObject =', factorsAsObject);\n\t\tconst primeFactors = Object.keys(factorsAsObject).map(p => parseInt(p, 10));\n\t\t//console.log('primeFactors =', primeFactors);\n\t\t//let result = divisorHelper(factorsAsObject, primeFactors, 0, primeFactors.length, 1);\n\n\t\t//result.sort();\t\t\t\t\t// Sorts the array in place. Lexicographic sort.\n\t\t// result.sort((a, b) => a - b);\t\t// Sorts the array in place. Numeric sort.\n\n\t\t// return result;\n\n\t\t//return result.sort((a, b) => a - b);\t\t// Sorts the array in place. Numeric sort.\n\n\t\treturn divisorHelper(factorsAsObject, primeFactors, 0, primeFactors.length, 1).sort((a, b) => a - b);\n\t}\n\n\tfunction sum (array) {\n\t\treturn array.reduce((accumulator, m) => accumulator + m, 0);\n\t}\n\n\tfunction isPerfect (n) {\n\t\treturn sum(divisors(n)) === 2 * n;\n\t}\n\n\tfunction removeDuplicates (array) {\n\t\treturn Array.from(new Set(array));\n\t}\n\n\tfunction totient (n) {\n\t\t// See https://en.wikipedia.org/wiki/Euler%27s_totient_function\n\t\t// See https://www.geeksforgeeks.org/eulers-totient-function/\n\n\t\tn = parseInt(n, 10);\n\n\t\tif (isNaN(n) || n < 2) {\n\t\t\tthrow new Error('Invalid argument');\n\t\t}\n\n\t\t/*\n\t\tconst primeFactorsOfN = removeDuplicates(factorize(n));\n\t\tlet result = n;\n\n\t\tprimeFactorsOfN.forEach(p => {\n\t\t\tresult = result * (p - 1) / p;\n\t\t});\n\n\t\treturn result;\n\t\t*/\n\n\t\treturn removeDuplicates(factorize(n)).reduce((accumulator, p) => accumulator * (p - 1) / p, n);\n\t}\n\n\t// Node, AMD, and window are supported.\n\n\tconst version = '0.0.0';\n\n\tif (typeof exports !== 'undefined') {\n\t\tmodule.exports = {\n\t\t\tversion: version,\n\t\t\tgcd: gcd,\n\t\t\tgcdExtended: gcdExtended,\n\t\t\tsieve: sieve,\n\t\t\tfactorize: factorize,\n\t\t\tcondenseFactorList: condenseFactorList,\n\t\t\tdivisors: divisors,\n\t\t\tisPerfect: isPerfect,\n\t\t\ttotient: totient\n\t\t};\n\t} else if (typeof define === 'function' && define.amd !== void 0) {\n\t\tdefine(() => {\n\t\t\treturn {\n\t\t\t\tversion: version,\n\t\t\t\tgcd: gcd,\n\t\t\t\tgcdExtended: gcdExtended,\n\t\t\t\tsieve: sieve,\n\t\t\t\tfactorize: factorize,\n\t\t\t\tcondenseFactorList: condenseFactorList,\n\t\t\t\tdivisors: divisors,\n\t\t\t\tisPerfect: isPerfect,\n\t\t\t\ttotient: totient\n\t\t\t};\n\t\t});\n\t} else {\n\t\tglobal.gcd = gcd;\n\t\tglobal.gcdExtended = gcdExtended;\n\t\tglobal.sieve = sieve;\n\t\tglobal.factorize = factorize;\n\t\tglobal.condenseFactorList = condenseFactorList;\n\t\tglobal.divisors = divisors;\n\t\tglobal.isPerfect = isPerfect;\n\t\tglobal.totient = totient;\n\t}\n}(typeof window !== 'undefined' ? window : global));\n"]}