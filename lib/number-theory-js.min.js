/*
 2018 [object Object]
 @version 0.0.0
*/
'use strict';(function(a){function b(a,c){if(a=parseInt(a,10),c=parseInt(c,10),isNaN(a)||isNaN(c))throw new Error('Invalid arguments');else return 0>c?b(a,-c):a<c?b(c,a):0===c?a:b(c,a%c)}function c(a,b){for(let c of b){if(c*c>a)return!0;if(0==a%c)return!1}return!0}function d(a){if(a=parseInt(a,10),isNaN(a))throw new Error('Invalid argument');else if(2>=a)return[];let b=[2];for(let d=3;d<a;d+=2)c(d,b)&&b.push(d);return b}function e(a){if(a=parseInt(a,10),isNaN(a))throw new Error('Invalid argument');else if(2>a)return[];for(let b=[],d=[],e=2,f=1;;){if(e*e>a)return d.push(a),d;if(c(e,b))for(b.push(e);0==a%e;)if(a/=e,d.push(e),1===a)return d;e+=f,f=2}}function f(a){return Array.from(new Set(a))}function g(a){const b=f(e(a));let c=a;return b.forEach((a)=>{c=c*(a-1)/a}),c}b.partial=(a)=>(c)=>b(a,c);const h='0.0.0';'undefined'==typeof exports?'function'==typeof define&&void 0!==define.amd?define(()=>({version:h,gcd:b,sieve:d,factorize:e,totient:g})):(a.gcd=b,a.sieve=d,a.factorize=e,a.totient=g):module.exports={version:h,gcd:b,sieve:d,factorize:e,totient:g}})('undefined'==typeof window?global:window);
//# sourceMappingURL=number-theory-js.min.js.map